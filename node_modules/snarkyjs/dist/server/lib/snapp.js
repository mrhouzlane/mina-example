import { Circuit, Field, Bool, Poseidon } from '../snarky';
import { AccountPredicate, Body, Party, } from './party';
import * as Mina from './mina';
import { UInt32 } from './int';
/**
 * Gettable and settable state that can be checked for equality.
 */
export function State() {
    return createState();
}
function createState() {
    return {
        _initialized: false,
        _key: undefined,
        _ty: undefined,
        _this: undefined,
        _SnappClass: undefined,
        _init(key, ty, _this, SnappClass) {
            this._initialized = true;
            this._key = key;
            this._ty = ty;
            this._this = _this;
            this._SnappClass = SnappClass;
        },
        getLayout() {
            const layout = this._SnappClass._layout();
            const r = layout.get(this._key);
            if (r === undefined) {
                throw new Error(`state ${this._key} not found`);
            }
            return r;
        },
        set(a) {
            if (!this._initialized)
                throw Error('set can only be called when the State is assigned to a SmartContract @state.');
            const r = this.getLayout();
            const xs = this._ty.toFields(a);
            let e = this._this.executionState();
            xs.forEach((x, i) => {
                e.party.body.update.appState[r.offset + i].setValue(x);
            });
        },
        assertEquals(a) {
            if (!this._initialized)
                throw Error('assertEquals can only be called when the State is assigned to a SmartContract @state.');
            const r = this.getLayout();
            const xs = this._ty.toFields(a);
            let e = this._this.executionState();
            xs.forEach((x, i) => {
                e.party.predicate.state[r.offset + i].check = new Bool(true);
                e.party.predicate.state[r.offset + i].value = x;
            });
        },
        async get() {
            if (!this._initialized)
                throw Error('get can only be called when the State is assigned to a SmartContract @state.');
            const r = this.getLayout();
            let addr = this._this.address;
            let p;
            if (Circuit.inProver()) {
                p = Mina.getAccount(addr).then((a) => {
                    const xs = [];
                    for (let i = 0; i < r.length; ++i) {
                        xs.push(a.snapp.appState[r.offset + i]);
                    }
                    return Circuit.witness(Circuit.array(Field, r.length), () => xs);
                });
            }
            else {
                const res = Circuit.witness(Circuit.array(Field, r.length), () => {
                    throw Error('this should never happen');
                });
                p = new Promise((k) => k(res));
            }
            let xs = await p;
            const res = this._ty.ofFields(xs);
            if (this._ty.check != undefined) {
                this._ty.check(res);
            }
            return res;
        },
    };
}
/**
 * A decorator to use within a snapp to indicate what will be stored on-chain.
 * For example, if you want to store a field element `some_state` in a snapp,
 * you can use the following in the declaration of your snapp:
 *
 * ```
 * @state(Field) some_state = State<Field>();
 * ```
 *
 */
export function state(ty) {
    return function (target, key, _descriptor) {
        const SnappClass = target.constructor;
        if (!(SnappClass.prototype instanceof SmartContract)) {
            throw new Error('Can only use @state decorator on classes that extend SmartContract');
        }
        // TBD: ok to not check? bc type metadata not inferred from class field assignment
        // const fieldType = Reflect.getMetadata('design:type', target, key);
        // if (fieldType != State) {
        //   throw new Error(
        //     `@state fields must have type State<A> for some type A, got ${fieldType}`
        //   );
        // }
        if (key === '_states' || key === '_layout') {
            throw new Error('Property names _states and _layout reserved.');
        }
        if (SnappClass._states == undefined) {
            SnappClass._states = [];
            let layout;
            SnappClass._layout = () => {
                if (layout === undefined) {
                    layout = new Map();
                    let offset = 0;
                    SnappClass._states.forEach(([key, ty]) => {
                        let length = ty.sizeInFields();
                        layout.set(key, { offset, length });
                        offset += length;
                    });
                }
                return layout;
            };
        }
        SnappClass._states.push([key, ty]);
        Object.defineProperty(target, key, {
            get() {
                return this._?.[key];
            },
            set(v) {
                if (v._initialized)
                    throw Error('A State should only be assigned once to a SmartContract');
                if (this._?.[key])
                    throw Error('A @state should only be assigned once');
                v._init(key, ty, this, SnappClass);
                (this._ ?? (this._ = {}))[key] = v;
            },
        });
    };
}
/**
 * A decorator to use in a snapp to mark a method as callable by anyone.
 * You can use inside your snapp class as:
 *
 * ```
 * @method async my_method(some_arg: Field) {
 *  // your code here
 * }
 * ```
 */
export function method(target, propertyName, _descriptor) { }
/**
 * The main snapp class. To write a snapp, extend this class as such:
 *
 * ```
 * class YourSmartContract extends SmartContract {
 *   // your smart contract code here
 * }
 * ```
 *
 */
export class SmartContract {
    constructor(address) {
        this.address = address;
        // this.self = null as unknown as Body;
        // this.state = [];
    }
    deploy(...args) {
        try {
            this.executionState().party.body.update.verificationKey.set = Bool(true);
        }
        catch (_error) {
            throw new Error('Cannot deploy SmartContract outside a transaction.');
        }
    }
    executionState() {
        if (Mina.currentTransaction === undefined) {
            throw new Error('Cannot execute outside of a Mina.transaction() block.');
        }
        if (this._executionState !== undefined &&
            this._executionState.transactionId === Mina.nextTransactionId.value) {
            return this._executionState;
        }
        else {
            const id = Mina.nextTransactionId.value;
            const index = Mina.currentTransaction.nextPartyIndex++;
            const body = Body.keepAll(this.address);
            const predicate = AccountPredicate.ignoreAll();
            const party = new Party(body, predicate);
            Mina.currentTransaction.parties.push(party);
            const s = {
                transactionId: id,
                partyIndex: index,
                party,
                protocolStatePredicate: Mina.currentTransaction.protocolState,
            };
            this._executionState = s;
            return s;
        }
    }
    get protocolState() {
        return this.executionState().protocolStatePredicate;
    }
    get self() {
        return this.executionState().party;
    }
    get balance() {
        return this.self.balance;
    }
    get nonce() {
        let p;
        if (Circuit.inProver()) {
            p = Mina.getAccount(this.address).then((a) => {
                return Circuit.witness(UInt32, () => a.nonce);
            });
        }
        else {
            const res = Circuit.witness(UInt32, () => {
                throw Error('this should never happen');
            });
            p = new Promise((resolve) => resolve(res));
        }
        return p.then((nonce) => {
            this.executionState().party.predicate.nonce.assertBetween(nonce, nonce);
            return nonce;
        });
    }
    party(i) {
        throw 'party';
    }
    transactionHash() {
        throw 'txn hash';
    }
    emitEvent(x) {
        // TODO: Get the current party object, pull out the events field, and
        // hash this together with what's there
        Poseidon.hash(x.toFields());
    }
}
