"use strict";
const typescript_estree_1 = require("@typescript-eslint/typescript-estree");
const ast_utils_1 = require("../utils/ast-utils");
const node_utils_1 = require("../utils/node-utils");
const selectors_1 = require("../utils/selectors");
const rule = {
    meta: {
        messages: {
            noIfInCircuit: 'A "if" statement should not be used in a circuit. Please use "Circuit.if" instead.',
        },
        schema: [],
        type: 'suggestion',
        docs: {
            description: 'A "if" statement should not be used in a circuit. Please use "Circuit.if" instead.',
            recommended: 'warn',
        },
    },
    create(context) {
        let snarkyCircuitMap = new Map();
        let ifSet = new Set();
        let callees = {};
        let callStack = [];
        let currentFunction = () => callStack[callStack.length - 1];
        function callsIf(functionName) {
            var _a;
            return ifSet.has(functionName) || !!((_a = callees[functionName]) === null || _a === void 0 ? void 0 : _a.some(callsIf));
        }
        return {
            'Program:exit': function (_node) {
                for (let circuitNode of snarkyCircuitMap.values()) {
                    (0, typescript_estree_1.simpleTraverse)(circuitNode, {
                        enter: (node) => {
                            if ((0, node_utils_1.isIfStatement)(node)) {
                                context.report({ messageId: 'noIfInCircuit', loc: node.loc });
                            }
                            if ((0, node_utils_1.isCallExpression)(node) &&
                                (0, node_utils_1.isIdentifier)(node.callee) &&
                                callsIf(node.callee.name)) {
                                context.report({
                                    messageId: `noIfInCircuit`,
                                    loc: node.loc,
                                });
                            }
                        },
                    });
                }
            },
            [selectors_1.CIRCUIT_METHOD_DECORATOR]: function (circuitMethodNode) {
                const functionName = (0, ast_utils_1.getFunctionName)(circuitMethodNode);
                if (functionName)
                    snarkyCircuitMap.set(functionName, circuitMethodNode);
            },
            ':function'(node) {
                callStack.push((0, ast_utils_1.getFunctionName)(node));
            },
            ':function:exit'() {
                callStack.pop();
            },
            IfStatement() {
                let functionName = currentFunction();
                if (functionName)
                    ifSet.add(functionName);
            },
            CallExpression(node) {
                let functionName = currentFunction();
                if (functionName && (0, node_utils_1.isIdentifier)(node.callee)) {
                    let currentCallees = callees[functionName] || (callees[functionName] = []);
                    currentCallees.push(node.callee.name);
                }
            },
        };
    },
};
module.exports = rule;
//# sourceMappingURL=no-if-in-circuit.js.map