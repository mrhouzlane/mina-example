"use strict";
const typescript_estree_1 = require("@typescript-eslint/typescript-estree");
const node_utils_1 = require("../utils/node-utils");
const ast_utils_1 = require("../utils/ast-utils");
const selectors_1 = require("../utils/selectors");
const rule = {
    meta: {
        messages: {
            noRandomInCircuit: 'JavaScript randomness usage should be avoided in a circuit. The randomness cannot be verified and thus should not be included in a circuit',
        },
        schema: [],
        type: 'suggestion',
        docs: {
            description: 'JavaScript randomness usage should be avoided in a circuit. The randomness cannot be verified and thus should not be included in a circuit',
            recommended: 'warn',
        },
    },
    create(context) {
        const bannedImports = new Set(['Math', 'crypto']);
        const bannedFunctions = new Set([
            'random',
            'getRandomValues',
            'randomBytes',
        ]);
        let snarkyCircuitMap = new Map();
        let randomSet = new Set();
        let callees = {};
        let callStack = [];
        let currentFunction = () => callStack[callStack.length - 1];
        function callsRandom(functionName) {
            var _a;
            return (randomSet.has(functionName) ||
                !!((_a = callees[functionName]) === null || _a === void 0 ? void 0 : _a.some(callsRandom)));
        }
        return {
            'Program:exit': function (_) {
                for (let circuitNode of snarkyCircuitMap.values()) {
                    (0, typescript_estree_1.simpleTraverse)(circuitNode, {
                        enter: (node) => {
                            if ((0, node_utils_1.isCallExpression)(node) &&
                                (0, ast_utils_1.isBannedCallExpression)(node, bannedImports, bannedFunctions)) {
                                context.report({
                                    messageId: 'noRandomInCircuit',
                                    loc: node.loc,
                                });
                            }
                            if ((0, node_utils_1.isCallExpression)(node) &&
                                (0, node_utils_1.isIdentifier)(node.callee) &&
                                callsRandom(node.callee.name)) {
                                context.report({
                                    messageId: `noRandomInCircuit`,
                                    loc: node.loc,
                                });
                            }
                        },
                    });
                }
            },
            ':function'(node) {
                callStack.push((0, ast_utils_1.getFunctionName)(node));
            },
            ':function:exit'() {
                callStack.pop();
            },
            [selectors_1.CIRCUIT_METHOD_DECORATOR]: function (circuitMethodNode) {
                const functionName = (0, ast_utils_1.getFunctionName)(circuitMethodNode);
                if (functionName)
                    snarkyCircuitMap.set(functionName, circuitMethodNode);
            },
            CallExpression(node) {
                let functionName = currentFunction();
                if (functionName &&
                    (0, ast_utils_1.isBannedCallExpression)(node, bannedImports, bannedFunctions)) {
                    randomSet.add(functionName);
                }
                if (functionName && (0, node_utils_1.isIdentifier)(node.callee)) {
                    let currentCallees = callees[functionName] || (callees[functionName] = []);
                    currentCallees.push(node.callee.name);
                }
            },
        };
    },
};
module.exports = rule;
//# sourceMappingURL=no-random-in-circuit.js.map