"use strict";
const typescript_estree_1 = require("@typescript-eslint/typescript-estree");
const ast_utils_1 = require("../utils/ast-utils");
const node_utils_1 = require("../utils/node-utils");
const selectors_1 = require("../utils/selectors");
const rule = {
    meta: {
        messages: {
            noThrowInCircuit: 'A "throw" statement should not be used in a circuit.',
        },
        schema: [],
        type: 'problem',
        docs: {
            description: 'A "throw" statement should not be used in a circuit.',
            recommended: 'error',
        },
    },
    create(context) {
        let snarkyCircuitMap = new Map();
        let throwSet = new Set();
        let callees = {};
        let callStack = [];
        let currentFunction = () => callStack[callStack.length - 1];
        function callsThrow(functionName) {
            var _a;
            return (throwSet.has(functionName) || !!((_a = callees[functionName]) === null || _a === void 0 ? void 0 : _a.some(callsThrow)));
        }
        return {
            'Program:exit': function (_) {
                for (let circuitNode of snarkyCircuitMap.values()) {
                    (0, typescript_estree_1.simpleTraverse)(circuitNode, {
                        enter: (node) => {
                            if ((0, node_utils_1.isThrowStatement)(node)) {
                                context.report({ messageId: 'noThrowInCircuit', loc: node.loc });
                            }
                            if ((0, node_utils_1.isCallExpression)(node) &&
                                (0, node_utils_1.isIdentifier)(node.callee) &&
                                callsThrow(node.callee.name)) {
                                context.report({
                                    messageId: `noThrowInCircuit`,
                                    loc: node.loc,
                                });
                            }
                        },
                    });
                }
            },
            [selectors_1.CIRCUIT_METHOD_DECORATOR]: function (circuitMethodNode) {
                const functionName = (0, ast_utils_1.getFunctionName)(circuitMethodNode);
                if (functionName)
                    snarkyCircuitMap.set(functionName, circuitMethodNode);
            },
            ':function'(node) {
                callStack.push((0, ast_utils_1.getFunctionName)(node));
            },
            ':function:exit'() {
                callStack.pop();
            },
            ThrowStatement() {
                let functionName = currentFunction();
                if (functionName)
                    throwSet.add(functionName);
            },
            CallExpression(node) {
                let functionName = currentFunction();
                if (functionName && (0, node_utils_1.isIdentifier)(node.callee)) {
                    let currentCallees = callees[functionName] || (callees[functionName] = []);
                    currentCallees.push(node.callee.name);
                }
            },
        };
    },
};
module.exports = rule;
//# sourceMappingURL=no-throw-in-circuit.js.map