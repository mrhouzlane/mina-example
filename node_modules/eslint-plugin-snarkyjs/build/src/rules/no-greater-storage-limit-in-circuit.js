"use strict";
const typescript_estree_1 = require("@typescript-eslint/typescript-estree");
const ast_utils_1 = require("../utils/ast-utils");
const selectors_1 = require("../utils/selectors");
const MAX_CONTRACT_STATES = 8;
const SnarkyJSPrimitiveNames = [
    'Field',
    'Bool',
    'UInt32',
    'Uint64',
    'Scalar',
    'PrivateKey',
    'Group',
    'PublicKey',
    'Signature',
];
const isSnarkyJSPrimitive = (p) => SnarkyJSPrimitiveNames.includes(p);
const SnarkyJSPrimitiveSizeInfo = {
    Field: { size: 1 },
    Bool: { size: 1 },
    Scalar: { size: 1 },
    UInt32: { size: 1 },
    Uint64: { size: 1 },
    PrivateKey: { size: 1 },
    Group: { size: 2 },
    PublicKey: { size: 2 },
    Signature: { size: 2 },
};
const rule = {
    meta: {
        messages: {
            noGreaterStorageLimitInCircuit: `A circuit can only have ${MAX_CONTRACT_STATES} allowed storage fields.`,
        },
        schema: [],
        type: 'problem',
        docs: {
            description: `A circuit can only have ${MAX_CONTRACT_STATES} allowed storage fields.`,
            recommended: 'error',
            url: '',
        },
    },
    create(context) {
        // Store SmartContact class name as the key and a list of `CircuitDecoratorInfo` that represents each storage state
        let smartContractMap = new Map();
        // Store CircuitValue class name as the key and a list of `CircuitDecoratorInfo` that represents each storage state
        let circuitValueMap = new Map();
        return {
            'Program:exit': function (_) {
                smartContractMap.forEach((circuitDecorators, _) => {
                    let stateCount = 0;
                    circuitDecorators.forEach((circuitDecorator) => {
                        var _a;
                        // Check if the state decorator is held within a CircuitValue class
                        // otherwise check if it is a SnarkyJS primitive to get it's state size
                        if (circuitValueMap.has(circuitDecorator.decoratorType)) {
                            const circuitValueStates = (_a = circuitValueMap.get(circuitDecorator.decoratorType)) !== null && _a !== void 0 ? _a : [];
                            circuitValueStates.forEach((circuitValueState) => {
                                if (circuitValueState.typeSize)
                                    stateCount += circuitValueState.typeSize;
                            });
                        }
                        else if (isSnarkyJSPrimitive(circuitDecorator.decoratorType)) {
                            const stateSize = SnarkyJSPrimitiveSizeInfo[circuitDecorator.decoratorType].size;
                            stateCount += stateSize;
                        }
                        if (stateCount > MAX_CONTRACT_STATES) {
                            context.report({
                                messageId: `noGreaterStorageLimitInCircuit`,
                                loc: circuitDecorator.node.loc,
                            });
                        }
                    });
                });
            },
            [selectors_1.SMART_CONTRACT_DEFINITION]: function (smartContractNode) {
                var _a, _b;
                let circuitStates = [];
                (0, typescript_estree_1.simpleTraverse)(smartContractNode, {
                    enter: (node) => {
                        var _a;
                        const decorators = (0, ast_utils_1.getDecorators)(node);
                        const stateDecorator = (0, ast_utils_1.getSpecifiedDecorator)(decorators, 'state');
                        if (stateDecorator) {
                            const decoratorType = (_a = (0, ast_utils_1.getFirstDecoratorValue)(stateDecorator)) !== null && _a !== void 0 ? _a : (0, ast_utils_1.getPropertyType)(node);
                            if (decoratorType) {
                                circuitStates.push({
                                    decoratorType,
                                    decoratorKind: 'state',
                                    node,
                                });
                            }
                        }
                    },
                });
                if ((_a = smartContractNode.id) === null || _a === void 0 ? void 0 : _a.name)
                    smartContractMap.set((_b = smartContractNode.id) === null || _b === void 0 ? void 0 : _b.name, circuitStates);
            },
            [selectors_1.CIRCUIT_VALUE_DEFINITION]: function (circuitValueNode) {
                var _a, _b;
                let circuitStates = [];
                (0, typescript_estree_1.simpleTraverse)(circuitValueNode, {
                    enter: (node) => {
                        var _a, _b;
                        const decorators = (0, ast_utils_1.getDecorators)(node);
                        const propDecorator = (0, ast_utils_1.getSpecifiedDecorator)(decorators, 'prop');
                        const arrayPropDecorator = (0, ast_utils_1.getSpecifiedDecorator)(decorators, 'arrayProp');
                        if (propDecorator) {
                            const decoratorType = (_a = (0, ast_utils_1.getFirstDecoratorValue)(propDecorator)) !== null && _a !== void 0 ? _a : (0, ast_utils_1.getPropertyType)(node);
                            if (decoratorType) {
                                const typeSize = SnarkyJSPrimitiveSizeInfo[decoratorType].size;
                                circuitStates.push({
                                    decoratorType,
                                    decoratorKind: 'prop',
                                    typeSize,
                                    node: circuitValueNode,
                                });
                            }
                        }
                        else if (arrayPropDecorator) {
                            const decoratorType = (_b = (0, ast_utils_1.getFirstDecoratorValue)(arrayPropDecorator)) !== null && _b !== void 0 ? _b : (0, ast_utils_1.getPropertyType)(node);
                            if (decoratorType) {
                                const size = SnarkyJSPrimitiveSizeInfo[decoratorType].size;
                                circuitStates.push({
                                    decoratorType,
                                    decoratorKind: 'arrayProp',
                                    typeSize: (0, ast_utils_1.getSecondDecoratorValue)(arrayPropDecorator) *
                                        size,
                                    node: circuitValueNode,
                                });
                            }
                        }
                    },
                });
                if ((_a = circuitValueNode.id) === null || _a === void 0 ? void 0 : _a.name)
                    circuitValueMap.set((_b = circuitValueNode.id) === null || _b === void 0 ? void 0 : _b.name, circuitStates);
            },
        };
    },
};
module.exports = rule;
//# sourceMappingURL=no-greater-storage-limit-in-circuit.js.map